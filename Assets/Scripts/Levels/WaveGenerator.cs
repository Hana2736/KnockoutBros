using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Network; // <-- Add this
using Util;

public class WaveGenerator : MonoBehaviour
{
    public GameObject wavePrefab;
    float timeToReachMaxRate = 120f;
    float initialMaxSpawnDelay = 8f;
    float finalMaxSpawnDelay = 5f;
    float initialMinSpawnDelay = 4f;

    float finalMinSpawnDelay = 3f;
    private List<Vector3[]> paths;
    private NetServer netServer; // <-- Add reference to the server

    void Start()
    {
        // This component should only be active on the server.
        if (NetServer.BuiltRunningMode != NetServer.RunningMode.Server)
        {
            this.enabled = false;
            return;
        }

        // Get the NetServer instance to send messages
        netServer = Object.FindAnyObjectByType<NetServer>();
        if (netServer == null)
        {
            Debug.LogError("WaveGenerator could not find the NetServer instance!");
            this.enabled = false;
            return;
        }

        InitializePaths();
        StartCoroutine(SpawnWaves());
    }

    void InitializePaths()
    {
        // ... (This method remains unchanged)
        paths = new List<Vector3[]>();

        paths.Add(new Vector3[] { new Vector3(0, -0.88f, -19.5f),    new Vector3(0, -0.21f, -17.87f),   new Vector3(0, -0.21f, 17.87f),    new Vector3(0, -0.88f, 19.5f) });
        paths.Add(new Vector3[] { new Vector3(0, -0.88f, 19.5f), new Vector3(0, -0.21f, 17.87f), new Vector3(0, -0.21f, -17.87f), new Vector3(0, -0.88f, -19.5f) });
        paths.Add(new Vector3[] { new Vector3(-19.5f, -0.88f, 0), new Vector3(-17.87f, -0.21f, 0), new Vector3(17.87f, -0.21f, 0), new Vector3(19.5f, -0.88f, 0) });
        paths.Add(new Vector3[] { new Vector3(19.5f, -0.88f, 0), new Vector3(17.87f, -0.21f, 0), new Vector3(-17.87f, -0.21f, 0), new Vector3(-19.5f, -0.88f, 0) });
    }

    IEnumerator SpawnWaves()
    {
        yield return new WaitForSeconds(15);
        while (true)
        {
            float progress = Mathf.Clamp01(Time.timeSinceLevelLoad / timeToReachMaxRate);
            float currentMinDelay = Mathf.Lerp(initialMinSpawnDelay, finalMinSpawnDelay, progress);
            float currentMaxDelay = Mathf.Lerp(initialMaxSpawnDelay, finalMaxSpawnDelay, progress);

            yield return new WaitForSeconds(Random.Range(currentMinDelay, currentMaxDelay));

            // 1. Server generates all the random properties for the wave
            int pathIndex = Random.Range(0, paths.Count);
            float waveSpeed = Random.Range(5f, 8f);

            // 2. Server packs these properties into a message and sends to everyone
            var waveMessage = new MessagePacker.NewWaveMessage { pathIndex = pathIndex, speed = waveSpeed };
            netServer.SendMessage(MessagePacker.PackNewWaveMessage(waveMessage));

            // 3. Server also spawns the wave in its own world
            SpawnWaveForReal(pathIndex, waveSpeed);
        }
    }

    // This method performs the actual instantiation of the wave
    public void SpawnWaveForReal(int pathIndex, float speed)
    {
        if (pathIndex < 0 || pathIndex >= paths.Count) return;

        Vector3[] selectedPath = paths[pathIndex];
        Quaternion waveRotation = Quaternion.identity;

        if (pathIndex == 2 || pathIndex == 3)
        {
            waveRotation = Quaternion.Euler(0, 90, 0);
        }

        GameObject waveInstance = Instantiate(wavePrefab, selectedPath[0], waveRotation, new InstantiateParameters()
        {
            parent = LevelLoader.parentForItems.transform,
            worldSpace = true
        });

        WaveMove waveMoveScript = waveInstance.GetComponent<WaveMove>();
        if (waveMoveScript != null)
        {
            waveMoveScript.Initialize(selectedPath, speed); // Use the speed generated by the server
        }
    }
}